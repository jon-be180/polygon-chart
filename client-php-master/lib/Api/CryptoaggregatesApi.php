<?php
/**
 * CryptoaggregatesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Polygon API
 *
 * The future of fintech.
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.3.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * CryptoaggregatesApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class CryptoaggregatesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'cryptoMACD' => [
            'application/json',
        ],
        'v2AggsGroupedLocaleGlobalMarketCryptoDateGet' => [
            'application/json',
        ],
        'v2AggsTickerCryptoTickerPrevGet' => [
            'application/json',
        ],
        'v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation cryptoMACD
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $crypto_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The price in the aggregate which will be used to calculate MACD data. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cryptoMACD'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CryptoMACD200Response
     */
    public function cryptoMACD($crypto_ticker, $timestamp = null, $timespan = 'day', $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['cryptoMACD'][0])
    {
        list($response) = $this->cryptoMACDWithHttpInfo($crypto_ticker, $timestamp, $timespan, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);
        return $response;
    }

    /**
     * Operation cryptoMACDWithHttpInfo
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $crypto_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The price in the aggregate which will be used to calculate MACD data. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cryptoMACD'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CryptoMACD200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function cryptoMACDWithHttpInfo($crypto_ticker, $timestamp = null, $timespan = 'day', $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['cryptoMACD'][0])
    {
        $request = $this->cryptoMACDRequest($crypto_ticker, $timestamp, $timespan, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CryptoMACD200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CryptoMACD200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CryptoMACD200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CryptoMACD200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CryptoMACD200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cryptoMACDAsync
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $crypto_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The price in the aggregate which will be used to calculate MACD data. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cryptoMACD'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cryptoMACDAsync($crypto_ticker, $timestamp = null, $timespan = 'day', $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['cryptoMACD'][0])
    {
        return $this->cryptoMACDAsyncWithHttpInfo($crypto_ticker, $timestamp, $timespan, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cryptoMACDAsyncWithHttpInfo
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $crypto_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The price in the aggregate which will be used to calculate MACD data. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cryptoMACD'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cryptoMACDAsyncWithHttpInfo($crypto_ticker, $timestamp = null, $timespan = 'day', $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['cryptoMACD'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CryptoMACD200Response';
        $request = $this->cryptoMACDRequest($crypto_ticker, $timestamp, $timespan, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cryptoMACD'
     *
     * @param  string $crypto_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The price in the aggregate which will be used to calculate MACD data. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cryptoMACD'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cryptoMACDRequest($crypto_ticker, $timestamp = null, $timespan = 'day', $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['cryptoMACD'][0])
    {

        // verify the required parameter 'crypto_ticker' is set
        if ($crypto_ticker === null || (is_array($crypto_ticker) && count($crypto_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_ticker when calling cryptoMACD'
            );
        }









        if ($limit !== null && $limit > 5000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling CryptoaggregatesApi.cryptoMACD, must be smaller than or equal to 5000.');
        }
        





        $resourcePath = '/v1/indicators/macd/{cryptoTicker}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short_window,
            'short_window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $long_window,
            'long_window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $signal_window,
            'signal_window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_type,
            'series_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_underlying,
            'expand_underlying', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gte,
            'timestamp.gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gt,
            'timestamp.gt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lte,
            'timestamp.lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lt,
            'timestamp.lt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($crypto_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoTicker' . '}',
                ObjectSerializer::toPathValue($crypto_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v2AggsGroupedLocaleGlobalMarketCryptoDateGet
     *
     * Grouped Daily (Bars)
     *
     * @param  string $date The beginning date for the aggregate window. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsGroupedLocaleGlobalMarketCryptoDateGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response
     */
    public function v2AggsGroupedLocaleGlobalMarketCryptoDateGet($date, $adjusted = null, string $contentType = self::contentTypes['v2AggsGroupedLocaleGlobalMarketCryptoDateGet'][0])
    {
        list($response) = $this->v2AggsGroupedLocaleGlobalMarketCryptoDateGetWithHttpInfo($date, $adjusted, $contentType);
        return $response;
    }

    /**
     * Operation v2AggsGroupedLocaleGlobalMarketCryptoDateGetWithHttpInfo
     *
     * Grouped Daily (Bars)
     *
     * @param  string $date The beginning date for the aggregate window. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsGroupedLocaleGlobalMarketCryptoDateGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2AggsGroupedLocaleGlobalMarketCryptoDateGetWithHttpInfo($date, $adjusted = null, string $contentType = self::contentTypes['v2AggsGroupedLocaleGlobalMarketCryptoDateGet'][0])
    {
        $request = $this->v2AggsGroupedLocaleGlobalMarketCryptoDateGetRequest($date, $adjusted, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2AggsGroupedLocaleGlobalMarketCryptoDateGetAsync
     *
     * Grouped Daily (Bars)
     *
     * @param  string $date The beginning date for the aggregate window. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsGroupedLocaleGlobalMarketCryptoDateGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsGroupedLocaleGlobalMarketCryptoDateGetAsync($date, $adjusted = null, string $contentType = self::contentTypes['v2AggsGroupedLocaleGlobalMarketCryptoDateGet'][0])
    {
        return $this->v2AggsGroupedLocaleGlobalMarketCryptoDateGetAsyncWithHttpInfo($date, $adjusted, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2AggsGroupedLocaleGlobalMarketCryptoDateGetAsyncWithHttpInfo
     *
     * Grouped Daily (Bars)
     *
     * @param  string $date The beginning date for the aggregate window. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsGroupedLocaleGlobalMarketCryptoDateGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsGroupedLocaleGlobalMarketCryptoDateGetAsyncWithHttpInfo($date, $adjusted = null, string $contentType = self::contentTypes['v2AggsGroupedLocaleGlobalMarketCryptoDateGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response';
        $request = $this->v2AggsGroupedLocaleGlobalMarketCryptoDateGetRequest($date, $adjusted, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2AggsGroupedLocaleGlobalMarketCryptoDateGet'
     *
     * @param  string $date The beginning date for the aggregate window. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsGroupedLocaleGlobalMarketCryptoDateGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2AggsGroupedLocaleGlobalMarketCryptoDateGetRequest($date, $adjusted = null, string $contentType = self::contentTypes['v2AggsGroupedLocaleGlobalMarketCryptoDateGet'][0])
    {

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling v2AggsGroupedLocaleGlobalMarketCryptoDateGet'
            );
        }



        $resourcePath = '/v2/aggs/grouped/locale/global/market/crypto/{date}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($date !== null) {
            $resourcePath = str_replace(
                '{' . 'date' . '}',
                ObjectSerializer::toPathValue($date),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v2AggsTickerCryptoTickerPrevGet
     *
     * Previous Close
     *
     * @param  string $crypto_ticker The ticker symbol of the currency pair. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerCryptoTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response
     */
    public function v2AggsTickerCryptoTickerPrevGet($crypto_ticker, $adjusted = null, string $contentType = self::contentTypes['v2AggsTickerCryptoTickerPrevGet'][0])
    {
        list($response) = $this->v2AggsTickerCryptoTickerPrevGetWithHttpInfo($crypto_ticker, $adjusted, $contentType);
        return $response;
    }

    /**
     * Operation v2AggsTickerCryptoTickerPrevGetWithHttpInfo
     *
     * Previous Close
     *
     * @param  string $crypto_ticker The ticker symbol of the currency pair. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerCryptoTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2AggsTickerCryptoTickerPrevGetWithHttpInfo($crypto_ticker, $adjusted = null, string $contentType = self::contentTypes['v2AggsTickerCryptoTickerPrevGet'][0])
    {
        $request = $this->v2AggsTickerCryptoTickerPrevGetRequest($crypto_ticker, $adjusted, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2AggsTickerCryptoTickerPrevGetAsync
     *
     * Previous Close
     *
     * @param  string $crypto_ticker The ticker symbol of the currency pair. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerCryptoTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerCryptoTickerPrevGetAsync($crypto_ticker, $adjusted = null, string $contentType = self::contentTypes['v2AggsTickerCryptoTickerPrevGet'][0])
    {
        return $this->v2AggsTickerCryptoTickerPrevGetAsyncWithHttpInfo($crypto_ticker, $adjusted, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2AggsTickerCryptoTickerPrevGetAsyncWithHttpInfo
     *
     * Previous Close
     *
     * @param  string $crypto_ticker The ticker symbol of the currency pair. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerCryptoTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerCryptoTickerPrevGetAsyncWithHttpInfo($crypto_ticker, $adjusted = null, string $contentType = self::contentTypes['v2AggsTickerCryptoTickerPrevGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response';
        $request = $this->v2AggsTickerCryptoTickerPrevGetRequest($crypto_ticker, $adjusted, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2AggsTickerCryptoTickerPrevGet'
     *
     * @param  string $crypto_ticker The ticker symbol of the currency pair. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerCryptoTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2AggsTickerCryptoTickerPrevGetRequest($crypto_ticker, $adjusted = null, string $contentType = self::contentTypes['v2AggsTickerCryptoTickerPrevGet'][0])
    {

        // verify the required parameter 'crypto_ticker' is set
        if ($crypto_ticker === null || (is_array($crypto_ticker) && count($crypto_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_ticker when calling v2AggsTickerCryptoTickerPrevGet'
            );
        }



        $resourcePath = '/v2/aggs/ticker/{cryptoTicker}/prev';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($crypto_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoTicker' . '}',
                ObjectSerializer::toPathValue($crypto_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet
     *
     * Aggregates (Bars)
     *
     * @param  string $crypto_ticker The ticker symbol of the currency pair. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response
     */
    public function v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet($crypto_ticker, $multiplier, $timespan, $from, $to, $adjusted = null, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'][0])
    {
        list($response) = $this->v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetWithHttpInfo($crypto_ticker, $multiplier, $timespan, $from, $to, $adjusted, $sort, $limit, $contentType);
        return $response;
    }

    /**
     * Operation v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetWithHttpInfo
     *
     * Aggregates (Bars)
     *
     * @param  string $crypto_ticker The ticker symbol of the currency pair. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetWithHttpInfo($crypto_ticker, $multiplier, $timespan, $from, $to, $adjusted = null, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'][0])
    {
        $request = $this->v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetRequest($crypto_ticker, $multiplier, $timespan, $from, $to, $adjusted, $sort, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetAsync
     *
     * Aggregates (Bars)
     *
     * @param  string $crypto_ticker The ticker symbol of the currency pair. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetAsync($crypto_ticker, $multiplier, $timespan, $from, $to, $adjusted = null, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'][0])
    {
        return $this->v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetAsyncWithHttpInfo($crypto_ticker, $multiplier, $timespan, $from, $to, $adjusted, $sort, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetAsyncWithHttpInfo
     *
     * Aggregates (Bars)
     *
     * @param  string $crypto_ticker The ticker symbol of the currency pair. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetAsyncWithHttpInfo($crypto_ticker, $multiplier, $timespan, $from, $to, $adjusted = null, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response';
        $request = $this->v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetRequest($crypto_ticker, $multiplier, $timespan, $from, $to, $adjusted, $sort, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'
     *
     * @param  string $crypto_ticker The ticker symbol of the currency pair. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetRequest($crypto_ticker, $multiplier, $timespan, $from, $to, $adjusted = null, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'][0])
    {

        // verify the required parameter 'crypto_ticker' is set
        if ($crypto_ticker === null || (is_array($crypto_ticker) && count($crypto_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_ticker when calling v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'multiplier' is set
        if ($multiplier === null || (is_array($multiplier) && count($multiplier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $multiplier when calling v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'timespan' is set
        if ($timespan === null || (is_array($timespan) && count($timespan) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $timespan when calling v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet'
            );
        }





        $resourcePath = '/v2/aggs/ticker/{cryptoTicker}/range/{multiplier}/{timespan}/{from}/{to}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($crypto_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoTicker' . '}',
                ObjectSerializer::toPathValue($crypto_ticker),
                $resourcePath
            );
        }
        // path params
        if ($multiplier !== null) {
            $resourcePath = str_replace(
                '{' . 'multiplier' . '}',
                ObjectSerializer::toPathValue($multiplier),
                $resourcePath
            );
        }
        // path params
        if ($timespan !== null) {
            $resourcePath = str_replace(
                '{' . 'timespan' . '}',
                ObjectSerializer::toPathValue($timespan),
                $resourcePath
            );
        }
        // path params
        if ($from !== null) {
            $resourcePath = str_replace(
                '{' . 'from' . '}',
                ObjectSerializer::toPathValue($from),
                $resourcePath
            );
        }
        // path params
        if ($to !== null) {
            $resourcePath = str_replace(
                '{' . 'to' . '}',
                ObjectSerializer::toPathValue($to),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
