<?php
/**
 * StocksaggregatesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Polygon API
 *
 * The future of fintech.
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.3.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * StocksaggregatesApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class StocksaggregatesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'eMA' => [
            'application/json',
        ],
        'mACD' => [
            'application/json',
        ],
        'rSI' => [
            'application/json',
        ],
        'sMA' => [
            'application/json',
        ],
        'v2AggsGroupedLocaleUsMarketStocksDateGet' => [
            'application/json',
        ],
        'v2AggsTickerStocksTickerPrevGet' => [
            'application/json',
        ],
        'v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation eMA
     *
     * Exponential Moving Average (EMA)
     *
     * @param  string $stock_ticker The ticker symbol for which to get exponential moving average (EMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['eMA'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CryptoEMA200Response
     */
    public function eMA($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['eMA'][0])
    {
        list($response) = $this->eMAWithHttpInfo($stock_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);
        return $response;
    }

    /**
     * Operation eMAWithHttpInfo
     *
     * Exponential Moving Average (EMA)
     *
     * @param  string $stock_ticker The ticker symbol for which to get exponential moving average (EMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['eMA'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CryptoEMA200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function eMAWithHttpInfo($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['eMA'][0])
    {
        $request = $this->eMARequest($stock_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CryptoEMA200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CryptoEMA200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CryptoEMA200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CryptoEMA200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CryptoEMA200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eMAAsync
     *
     * Exponential Moving Average (EMA)
     *
     * @param  string $stock_ticker The ticker symbol for which to get exponential moving average (EMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['eMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eMAAsync($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['eMA'][0])
    {
        return $this->eMAAsyncWithHttpInfo($stock_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eMAAsyncWithHttpInfo
     *
     * Exponential Moving Average (EMA)
     *
     * @param  string $stock_ticker The ticker symbol for which to get exponential moving average (EMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['eMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eMAAsyncWithHttpInfo($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['eMA'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CryptoEMA200Response';
        $request = $this->eMARequest($stock_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eMA'
     *
     * @param  string $stock_ticker The ticker symbol for which to get exponential moving average (EMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['eMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function eMARequest($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['eMA'][0])
    {

        // verify the required parameter 'stock_ticker' is set
        if ($stock_ticker === null || (is_array($stock_ticker) && count($stock_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stock_ticker when calling eMA'
            );
        }








        if ($limit !== null && $limit > 5000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling StocksaggregatesApi.eMA, must be smaller than or equal to 5000.');
        }
        





        $resourcePath = '/v1/indicators/ema/{stockTicker}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $window,
            'window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_type,
            'series_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_underlying,
            'expand_underlying', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gte,
            'timestamp.gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gt,
            'timestamp.gt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lte,
            'timestamp.lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lt,
            'timestamp.lt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($stock_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'stockTicker' . '}',
                ObjectSerializer::toPathValue($stock_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mACD
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $stock_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mACD'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CryptoMACD200Response
     */
    public function mACD($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['mACD'][0])
    {
        list($response) = $this->mACDWithHttpInfo($stock_ticker, $timestamp, $timespan, $adjusted, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);
        return $response;
    }

    /**
     * Operation mACDWithHttpInfo
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $stock_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mACD'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CryptoMACD200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function mACDWithHttpInfo($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['mACD'][0])
    {
        $request = $this->mACDRequest($stock_ticker, $timestamp, $timespan, $adjusted, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CryptoMACD200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CryptoMACD200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CryptoMACD200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CryptoMACD200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CryptoMACD200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mACDAsync
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $stock_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mACD'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mACDAsync($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['mACD'][0])
    {
        return $this->mACDAsyncWithHttpInfo($stock_ticker, $timestamp, $timespan, $adjusted, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mACDAsyncWithHttpInfo
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $stock_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mACD'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mACDAsyncWithHttpInfo($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['mACD'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CryptoMACD200Response';
        $request = $this->mACDRequest($stock_ticker, $timestamp, $timespan, $adjusted, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mACD'
     *
     * @param  string $stock_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mACD'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function mACDRequest($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['mACD'][0])
    {

        // verify the required parameter 'stock_ticker' is set
        if ($stock_ticker === null || (is_array($stock_ticker) && count($stock_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stock_ticker when calling mACD'
            );
        }










        if ($limit !== null && $limit > 5000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling StocksaggregatesApi.mACD, must be smaller than or equal to 5000.');
        }
        





        $resourcePath = '/v1/indicators/macd/{stockTicker}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short_window,
            'short_window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $long_window,
            'long_window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $signal_window,
            'signal_window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_type,
            'series_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_underlying,
            'expand_underlying', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gte,
            'timestamp.gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gt,
            'timestamp.gt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lte,
            'timestamp.lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lt,
            'timestamp.lt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($stock_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'stockTicker' . '}',
                ObjectSerializer::toPathValue($stock_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rSI
     *
     * Relative Strength Index (RSI)
     *
     * @param  string $stock_ticker The ticker symbol for which to get relative strength index (RSI) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param  string $series_type The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rSI'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CryptoRSI200Response
     */
    public function rSI($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 14, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['rSI'][0])
    {
        list($response) = $this->rSIWithHttpInfo($stock_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);
        return $response;
    }

    /**
     * Operation rSIWithHttpInfo
     *
     * Relative Strength Index (RSI)
     *
     * @param  string $stock_ticker The ticker symbol for which to get relative strength index (RSI) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param  string $series_type The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rSI'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CryptoRSI200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function rSIWithHttpInfo($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 14, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['rSI'][0])
    {
        $request = $this->rSIRequest($stock_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CryptoRSI200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CryptoRSI200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CryptoRSI200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CryptoRSI200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CryptoRSI200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rSIAsync
     *
     * Relative Strength Index (RSI)
     *
     * @param  string $stock_ticker The ticker symbol for which to get relative strength index (RSI) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param  string $series_type The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rSI'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rSIAsync($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 14, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['rSI'][0])
    {
        return $this->rSIAsyncWithHttpInfo($stock_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rSIAsyncWithHttpInfo
     *
     * Relative Strength Index (RSI)
     *
     * @param  string $stock_ticker The ticker symbol for which to get relative strength index (RSI) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param  string $series_type The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rSI'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rSIAsyncWithHttpInfo($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 14, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['rSI'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CryptoRSI200Response';
        $request = $this->rSIRequest($stock_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rSI'
     *
     * @param  string $stock_ticker The ticker symbol for which to get relative strength index (RSI) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param  string $series_type The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rSI'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function rSIRequest($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 14, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['rSI'][0])
    {

        // verify the required parameter 'stock_ticker' is set
        if ($stock_ticker === null || (is_array($stock_ticker) && count($stock_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stock_ticker when calling rSI'
            );
        }








        if ($limit !== null && $limit > 5000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling StocksaggregatesApi.rSI, must be smaller than or equal to 5000.');
        }
        





        $resourcePath = '/v1/indicators/rsi/{stockTicker}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $window,
            'window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_type,
            'series_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_underlying,
            'expand_underlying', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gte,
            'timestamp.gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gt,
            'timestamp.gt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lte,
            'timestamp.lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lt,
            'timestamp.lt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($stock_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'stockTicker' . '}',
                ObjectSerializer::toPathValue($stock_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sMA
     *
     * Simple Moving Average (SMA)
     *
     * @param  string $stock_ticker The ticker symbol for which to get simple moving average (SMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sMA'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CryptoSMA200Response
     */
    public function sMA($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['sMA'][0])
    {
        list($response) = $this->sMAWithHttpInfo($stock_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);
        return $response;
    }

    /**
     * Operation sMAWithHttpInfo
     *
     * Simple Moving Average (SMA)
     *
     * @param  string $stock_ticker The ticker symbol for which to get simple moving average (SMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sMA'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CryptoSMA200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function sMAWithHttpInfo($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['sMA'][0])
    {
        $request = $this->sMARequest($stock_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CryptoSMA200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CryptoSMA200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CryptoSMA200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CryptoSMA200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CryptoSMA200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sMAAsync
     *
     * Simple Moving Average (SMA)
     *
     * @param  string $stock_ticker The ticker symbol for which to get simple moving average (SMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sMAAsync($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['sMA'][0])
    {
        return $this->sMAAsyncWithHttpInfo($stock_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sMAAsyncWithHttpInfo
     *
     * Simple Moving Average (SMA)
     *
     * @param  string $stock_ticker The ticker symbol for which to get simple moving average (SMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sMAAsyncWithHttpInfo($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['sMA'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CryptoSMA200Response';
        $request = $this->sMARequest($stock_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sMA'
     *
     * @param  string $stock_ticker The ticker symbol for which to get simple moving average (SMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sMARequest($stock_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['sMA'][0])
    {

        // verify the required parameter 'stock_ticker' is set
        if ($stock_ticker === null || (is_array($stock_ticker) && count($stock_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stock_ticker when calling sMA'
            );
        }








        if ($limit !== null && $limit > 5000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling StocksaggregatesApi.sMA, must be smaller than or equal to 5000.');
        }
        





        $resourcePath = '/v1/indicators/sma/{stockTicker}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $window,
            'window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_type,
            'series_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_underlying,
            'expand_underlying', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gte,
            'timestamp.gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gt,
            'timestamp.gt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lte,
            'timestamp.lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lt,
            'timestamp.lt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($stock_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'stockTicker' . '}',
                ObjectSerializer::toPathValue($stock_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v2AggsGroupedLocaleUsMarketStocksDateGet
     *
     * Grouped Daily (Bars)
     *
     * @param  string $date The beginning date for the aggregate window. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  bool $include_otc Include OTC securities in the response. Default is false (don&#39;t include OTC securities). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsGroupedLocaleUsMarketStocksDateGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V2AggsGroupedLocaleUsMarketStocksDateGet200Response
     */
    public function v2AggsGroupedLocaleUsMarketStocksDateGet($date, $adjusted = null, $include_otc = null, string $contentType = self::contentTypes['v2AggsGroupedLocaleUsMarketStocksDateGet'][0])
    {
        list($response) = $this->v2AggsGroupedLocaleUsMarketStocksDateGetWithHttpInfo($date, $adjusted, $include_otc, $contentType);
        return $response;
    }

    /**
     * Operation v2AggsGroupedLocaleUsMarketStocksDateGetWithHttpInfo
     *
     * Grouped Daily (Bars)
     *
     * @param  string $date The beginning date for the aggregate window. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  bool $include_otc Include OTC securities in the response. Default is false (don&#39;t include OTC securities). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsGroupedLocaleUsMarketStocksDateGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V2AggsGroupedLocaleUsMarketStocksDateGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2AggsGroupedLocaleUsMarketStocksDateGetWithHttpInfo($date, $adjusted = null, $include_otc = null, string $contentType = self::contentTypes['v2AggsGroupedLocaleUsMarketStocksDateGet'][0])
    {
        $request = $this->v2AggsGroupedLocaleUsMarketStocksDateGetRequest($date, $adjusted, $include_otc, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\V2AggsGroupedLocaleUsMarketStocksDateGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V2AggsGroupedLocaleUsMarketStocksDateGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V2AggsGroupedLocaleUsMarketStocksDateGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\V2AggsGroupedLocaleUsMarketStocksDateGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V2AggsGroupedLocaleUsMarketStocksDateGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2AggsGroupedLocaleUsMarketStocksDateGetAsync
     *
     * Grouped Daily (Bars)
     *
     * @param  string $date The beginning date for the aggregate window. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  bool $include_otc Include OTC securities in the response. Default is false (don&#39;t include OTC securities). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsGroupedLocaleUsMarketStocksDateGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsGroupedLocaleUsMarketStocksDateGetAsync($date, $adjusted = null, $include_otc = null, string $contentType = self::contentTypes['v2AggsGroupedLocaleUsMarketStocksDateGet'][0])
    {
        return $this->v2AggsGroupedLocaleUsMarketStocksDateGetAsyncWithHttpInfo($date, $adjusted, $include_otc, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2AggsGroupedLocaleUsMarketStocksDateGetAsyncWithHttpInfo
     *
     * Grouped Daily (Bars)
     *
     * @param  string $date The beginning date for the aggregate window. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  bool $include_otc Include OTC securities in the response. Default is false (don&#39;t include OTC securities). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsGroupedLocaleUsMarketStocksDateGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsGroupedLocaleUsMarketStocksDateGetAsyncWithHttpInfo($date, $adjusted = null, $include_otc = null, string $contentType = self::contentTypes['v2AggsGroupedLocaleUsMarketStocksDateGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V2AggsGroupedLocaleUsMarketStocksDateGet200Response';
        $request = $this->v2AggsGroupedLocaleUsMarketStocksDateGetRequest($date, $adjusted, $include_otc, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2AggsGroupedLocaleUsMarketStocksDateGet'
     *
     * @param  string $date The beginning date for the aggregate window. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  bool $include_otc Include OTC securities in the response. Default is false (don&#39;t include OTC securities). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsGroupedLocaleUsMarketStocksDateGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2AggsGroupedLocaleUsMarketStocksDateGetRequest($date, $adjusted = null, $include_otc = null, string $contentType = self::contentTypes['v2AggsGroupedLocaleUsMarketStocksDateGet'][0])
    {

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling v2AggsGroupedLocaleUsMarketStocksDateGet'
            );
        }




        $resourcePath = '/v2/aggs/grouped/locale/us/market/stocks/{date}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_otc,
            'include_otc', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($date !== null) {
            $resourcePath = str_replace(
                '{' . 'date' . '}',
                ObjectSerializer::toPathValue($date),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v2AggsTickerStocksTickerPrevGet
     *
     * Previous Close
     *
     * @param  string $stocks_ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerStocksTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response
     */
    public function v2AggsTickerStocksTickerPrevGet($stocks_ticker, $adjusted = null, string $contentType = self::contentTypes['v2AggsTickerStocksTickerPrevGet'][0])
    {
        list($response) = $this->v2AggsTickerStocksTickerPrevGetWithHttpInfo($stocks_ticker, $adjusted, $contentType);
        return $response;
    }

    /**
     * Operation v2AggsTickerStocksTickerPrevGetWithHttpInfo
     *
     * Previous Close
     *
     * @param  string $stocks_ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerStocksTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2AggsTickerStocksTickerPrevGetWithHttpInfo($stocks_ticker, $adjusted = null, string $contentType = self::contentTypes['v2AggsTickerStocksTickerPrevGet'][0])
    {
        $request = $this->v2AggsTickerStocksTickerPrevGetRequest($stocks_ticker, $adjusted, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2AggsTickerStocksTickerPrevGetAsync
     *
     * Previous Close
     *
     * @param  string $stocks_ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerStocksTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerStocksTickerPrevGetAsync($stocks_ticker, $adjusted = null, string $contentType = self::contentTypes['v2AggsTickerStocksTickerPrevGet'][0])
    {
        return $this->v2AggsTickerStocksTickerPrevGetAsyncWithHttpInfo($stocks_ticker, $adjusted, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2AggsTickerStocksTickerPrevGetAsyncWithHttpInfo
     *
     * Previous Close
     *
     * @param  string $stocks_ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerStocksTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerStocksTickerPrevGetAsyncWithHttpInfo($stocks_ticker, $adjusted = null, string $contentType = self::contentTypes['v2AggsTickerStocksTickerPrevGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response';
        $request = $this->v2AggsTickerStocksTickerPrevGetRequest($stocks_ticker, $adjusted, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2AggsTickerStocksTickerPrevGet'
     *
     * @param  string $stocks_ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerStocksTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2AggsTickerStocksTickerPrevGetRequest($stocks_ticker, $adjusted = null, string $contentType = self::contentTypes['v2AggsTickerStocksTickerPrevGet'][0])
    {

        // verify the required parameter 'stocks_ticker' is set
        if ($stocks_ticker === null || (is_array($stocks_ticker) && count($stocks_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stocks_ticker when calling v2AggsTickerStocksTickerPrevGet'
            );
        }



        $resourcePath = '/v2/aggs/ticker/{stocksTicker}/prev';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($stocks_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'stocksTicker' . '}',
                ObjectSerializer::toPathValue($stocks_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet
     *
     * Aggregates (Bars)
     *
     * @param  string $stocks_ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response
     */
    public function v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet($stocks_ticker, $multiplier, $timespan, $from, $to, $adjusted = null, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'][0])
    {
        list($response) = $this->v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetWithHttpInfo($stocks_ticker, $multiplier, $timespan, $from, $to, $adjusted, $sort, $limit, $contentType);
        return $response;
    }

    /**
     * Operation v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetWithHttpInfo
     *
     * Aggregates (Bars)
     *
     * @param  string $stocks_ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetWithHttpInfo($stocks_ticker, $multiplier, $timespan, $from, $to, $adjusted = null, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'][0])
    {
        $request = $this->v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetRequest($stocks_ticker, $multiplier, $timespan, $from, $to, $adjusted, $sort, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetAsync
     *
     * Aggregates (Bars)
     *
     * @param  string $stocks_ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetAsync($stocks_ticker, $multiplier, $timespan, $from, $to, $adjusted = null, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'][0])
    {
        return $this->v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetAsyncWithHttpInfo($stocks_ticker, $multiplier, $timespan, $from, $to, $adjusted, $sort, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetAsyncWithHttpInfo
     *
     * Aggregates (Bars)
     *
     * @param  string $stocks_ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetAsyncWithHttpInfo($stocks_ticker, $multiplier, $timespan, $from, $to, $adjusted = null, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response';
        $request = $this->v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetRequest($stocks_ticker, $multiplier, $timespan, $from, $to, $adjusted, $sort, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'
     *
     * @param  string $stocks_ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetRequest($stocks_ticker, $multiplier, $timespan, $from, $to, $adjusted = null, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'][0])
    {

        // verify the required parameter 'stocks_ticker' is set
        if ($stocks_ticker === null || (is_array($stocks_ticker) && count($stocks_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stocks_ticker when calling v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'multiplier' is set
        if ($multiplier === null || (is_array($multiplier) && count($multiplier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $multiplier when calling v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'timespan' is set
        if ($timespan === null || (is_array($timespan) && count($timespan) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $timespan when calling v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet'
            );
        }





        $resourcePath = '/v2/aggs/ticker/{stocksTicker}/range/{multiplier}/{timespan}/{from}/{to}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($stocks_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'stocksTicker' . '}',
                ObjectSerializer::toPathValue($stocks_ticker),
                $resourcePath
            );
        }
        // path params
        if ($multiplier !== null) {
            $resourcePath = str_replace(
                '{' . 'multiplier' . '}',
                ObjectSerializer::toPathValue($multiplier),
                $resourcePath
            );
        }
        // path params
        if ($timespan !== null) {
            $resourcePath = str_replace(
                '{' . 'timespan' . '}',
                ObjectSerializer::toPathValue($timespan),
                $resourcePath
            );
        }
        // path params
        if ($from !== null) {
            $resourcePath = str_replace(
                '{' . 'from' . '}',
                ObjectSerializer::toPathValue($from),
                $resourcePath
            );
        }
        // path params
        if ($to !== null) {
            $resourcePath = str_replace(
                '{' . 'to' . '}',
                ObjectSerializer::toPathValue($to),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
