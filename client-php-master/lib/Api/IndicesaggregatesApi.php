<?php
/**
 * IndicesaggregatesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Polygon API
 *
 * The future of fintech.
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.3.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * IndicesaggregatesApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class IndicesaggregatesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'indicesEMA' => [
            'application/json',
        ],
        'indicesMACD' => [
            'application/json',
        ],
        'indicesRSI' => [
            'application/json',
        ],
        'indicesSMA' => [
            'application/json',
        ],
        'v2AggsTickerIndicesTickerPrevGet' => [
            'application/json',
        ],
        'v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation indicesEMA
     *
     * Exponential Moving Average (EMA)
     *
     * @param  string $indices_ticker The ticker symbol for which to get exponential moving average (EMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The value in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close values to  calculate the exponential moving average (EMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesEMA'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CryptoEMA200Response
     */
    public function indicesEMA($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesEMA'][0])
    {
        list($response) = $this->indicesEMAWithHttpInfo($indices_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);
        return $response;
    }

    /**
     * Operation indicesEMAWithHttpInfo
     *
     * Exponential Moving Average (EMA)
     *
     * @param  string $indices_ticker The ticker symbol for which to get exponential moving average (EMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The value in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close values to  calculate the exponential moving average (EMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesEMA'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CryptoEMA200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function indicesEMAWithHttpInfo($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesEMA'][0])
    {
        $request = $this->indicesEMARequest($indices_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CryptoEMA200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CryptoEMA200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CryptoEMA200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CryptoEMA200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CryptoEMA200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indicesEMAAsync
     *
     * Exponential Moving Average (EMA)
     *
     * @param  string $indices_ticker The ticker symbol for which to get exponential moving average (EMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The value in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close values to  calculate the exponential moving average (EMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesEMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indicesEMAAsync($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesEMA'][0])
    {
        return $this->indicesEMAAsyncWithHttpInfo($indices_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indicesEMAAsyncWithHttpInfo
     *
     * Exponential Moving Average (EMA)
     *
     * @param  string $indices_ticker The ticker symbol for which to get exponential moving average (EMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The value in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close values to  calculate the exponential moving average (EMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesEMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indicesEMAAsyncWithHttpInfo($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesEMA'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CryptoEMA200Response';
        $request = $this->indicesEMARequest($indices_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indicesEMA'
     *
     * @param  string $indices_ticker The ticker symbol for which to get exponential moving average (EMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The value in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close values to  calculate the exponential moving average (EMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesEMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function indicesEMARequest($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesEMA'][0])
    {

        // verify the required parameter 'indices_ticker' is set
        if ($indices_ticker === null || (is_array($indices_ticker) && count($indices_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indices_ticker when calling indicesEMA'
            );
        }








        if ($limit !== null && $limit > 5000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling IndicesaggregatesApi.indicesEMA, must be smaller than or equal to 5000.');
        }
        





        $resourcePath = '/v1/indicators/ema/{indicesTicker}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $window,
            'window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_type,
            'series_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_underlying,
            'expand_underlying', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gte,
            'timestamp.gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gt,
            'timestamp.gt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lte,
            'timestamp.lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lt,
            'timestamp.lt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($indices_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'indicesTicker' . '}',
                ObjectSerializer::toPathValue($indices_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indicesMACD
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $indices_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The value in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close values to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesMACD'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CryptoMACD200Response
     */
    public function indicesMACD($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesMACD'][0])
    {
        list($response) = $this->indicesMACDWithHttpInfo($indices_ticker, $timestamp, $timespan, $adjusted, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);
        return $response;
    }

    /**
     * Operation indicesMACDWithHttpInfo
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $indices_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The value in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close values to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesMACD'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CryptoMACD200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function indicesMACDWithHttpInfo($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesMACD'][0])
    {
        $request = $this->indicesMACDRequest($indices_ticker, $timestamp, $timespan, $adjusted, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CryptoMACD200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CryptoMACD200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CryptoMACD200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CryptoMACD200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CryptoMACD200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indicesMACDAsync
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $indices_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The value in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close values to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesMACD'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indicesMACDAsync($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesMACD'][0])
    {
        return $this->indicesMACDAsyncWithHttpInfo($indices_ticker, $timestamp, $timespan, $adjusted, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indicesMACDAsyncWithHttpInfo
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $indices_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The value in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close values to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesMACD'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indicesMACDAsyncWithHttpInfo($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesMACD'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CryptoMACD200Response';
        $request = $this->indicesMACDRequest($indices_ticker, $timestamp, $timespan, $adjusted, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indicesMACD'
     *
     * @param  string $indices_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The value in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close values to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesMACD'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function indicesMACDRequest($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesMACD'][0])
    {

        // verify the required parameter 'indices_ticker' is set
        if ($indices_ticker === null || (is_array($indices_ticker) && count($indices_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indices_ticker when calling indicesMACD'
            );
        }










        if ($limit !== null && $limit > 5000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling IndicesaggregatesApi.indicesMACD, must be smaller than or equal to 5000.');
        }
        





        $resourcePath = '/v1/indicators/macd/{indicesTicker}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short_window,
            'short_window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $long_window,
            'long_window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $signal_window,
            'signal_window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_type,
            'series_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_underlying,
            'expand_underlying', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gte,
            'timestamp.gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gt,
            'timestamp.gt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lte,
            'timestamp.lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lt,
            'timestamp.lt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($indices_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'indicesTicker' . '}',
                ObjectSerializer::toPathValue($indices_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indicesRSI
     *
     * Relative Strength Index (RSI)
     *
     * @param  string $indices_ticker The ticker symbol for which to get relative strength index (RSI) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param  string $series_type The value in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close values to  calculate the relative strength index (RSI). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesRSI'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CryptoRSI200Response
     */
    public function indicesRSI($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 14, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesRSI'][0])
    {
        list($response) = $this->indicesRSIWithHttpInfo($indices_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);
        return $response;
    }

    /**
     * Operation indicesRSIWithHttpInfo
     *
     * Relative Strength Index (RSI)
     *
     * @param  string $indices_ticker The ticker symbol for which to get relative strength index (RSI) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param  string $series_type The value in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close values to  calculate the relative strength index (RSI). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesRSI'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CryptoRSI200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function indicesRSIWithHttpInfo($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 14, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesRSI'][0])
    {
        $request = $this->indicesRSIRequest($indices_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CryptoRSI200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CryptoRSI200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CryptoRSI200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CryptoRSI200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CryptoRSI200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indicesRSIAsync
     *
     * Relative Strength Index (RSI)
     *
     * @param  string $indices_ticker The ticker symbol for which to get relative strength index (RSI) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param  string $series_type The value in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close values to  calculate the relative strength index (RSI). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesRSI'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indicesRSIAsync($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 14, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesRSI'][0])
    {
        return $this->indicesRSIAsyncWithHttpInfo($indices_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indicesRSIAsyncWithHttpInfo
     *
     * Relative Strength Index (RSI)
     *
     * @param  string $indices_ticker The ticker symbol for which to get relative strength index (RSI) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param  string $series_type The value in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close values to  calculate the relative strength index (RSI). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesRSI'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indicesRSIAsyncWithHttpInfo($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 14, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesRSI'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CryptoRSI200Response';
        $request = $this->indicesRSIRequest($indices_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indicesRSI'
     *
     * @param  string $indices_ticker The ticker symbol for which to get relative strength index (RSI) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param  string $series_type The value in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close values to  calculate the relative strength index (RSI). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesRSI'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function indicesRSIRequest($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 14, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesRSI'][0])
    {

        // verify the required parameter 'indices_ticker' is set
        if ($indices_ticker === null || (is_array($indices_ticker) && count($indices_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indices_ticker when calling indicesRSI'
            );
        }








        if ($limit !== null && $limit > 5000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling IndicesaggregatesApi.indicesRSI, must be smaller than or equal to 5000.');
        }
        





        $resourcePath = '/v1/indicators/rsi/{indicesTicker}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $window,
            'window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_type,
            'series_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_underlying,
            'expand_underlying', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gte,
            'timestamp.gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gt,
            'timestamp.gt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lte,
            'timestamp.lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lt,
            'timestamp.lt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($indices_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'indicesTicker' . '}',
                ObjectSerializer::toPathValue($indices_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indicesSMA
     *
     * Simple Moving Average (SMA)
     *
     * @param  string $indices_ticker The ticker symbol for which to get simple moving average (SMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The value in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close values to  calculate the simple moving average (SMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesSMA'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CryptoSMA200Response
     */
    public function indicesSMA($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesSMA'][0])
    {
        list($response) = $this->indicesSMAWithHttpInfo($indices_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);
        return $response;
    }

    /**
     * Operation indicesSMAWithHttpInfo
     *
     * Simple Moving Average (SMA)
     *
     * @param  string $indices_ticker The ticker symbol for which to get simple moving average (SMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The value in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close values to  calculate the simple moving average (SMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesSMA'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CryptoSMA200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function indicesSMAWithHttpInfo($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesSMA'][0])
    {
        $request = $this->indicesSMARequest($indices_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CryptoSMA200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CryptoSMA200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CryptoSMA200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CryptoSMA200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CryptoSMA200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indicesSMAAsync
     *
     * Simple Moving Average (SMA)
     *
     * @param  string $indices_ticker The ticker symbol for which to get simple moving average (SMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The value in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close values to  calculate the simple moving average (SMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesSMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indicesSMAAsync($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesSMA'][0])
    {
        return $this->indicesSMAAsyncWithHttpInfo($indices_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indicesSMAAsyncWithHttpInfo
     *
     * Simple Moving Average (SMA)
     *
     * @param  string $indices_ticker The ticker symbol for which to get simple moving average (SMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The value in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close values to  calculate the simple moving average (SMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesSMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indicesSMAAsyncWithHttpInfo($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesSMA'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CryptoSMA200Response';
        $request = $this->indicesSMARequest($indices_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indicesSMA'
     *
     * @param  string $indices_ticker The ticker symbol for which to get simple moving average (SMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The value in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close values to  calculate the simple moving average (SMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['indicesSMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function indicesSMARequest($indices_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['indicesSMA'][0])
    {

        // verify the required parameter 'indices_ticker' is set
        if ($indices_ticker === null || (is_array($indices_ticker) && count($indices_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indices_ticker when calling indicesSMA'
            );
        }








        if ($limit !== null && $limit > 5000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling IndicesaggregatesApi.indicesSMA, must be smaller than or equal to 5000.');
        }
        





        $resourcePath = '/v1/indicators/sma/{indicesTicker}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $window,
            'window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_type,
            'series_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_underlying,
            'expand_underlying', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gte,
            'timestamp.gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gt,
            'timestamp.gt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lte,
            'timestamp.lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lt,
            'timestamp.lt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($indices_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'indicesTicker' . '}',
                ObjectSerializer::toPathValue($indices_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v2AggsTickerIndicesTickerPrevGet
     *
     * Previous Close
     *
     * @param  string $indices_ticker The ticker symbol of Index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerIndicesTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response
     */
    public function v2AggsTickerIndicesTickerPrevGet($indices_ticker, string $contentType = self::contentTypes['v2AggsTickerIndicesTickerPrevGet'][0])
    {
        list($response) = $this->v2AggsTickerIndicesTickerPrevGetWithHttpInfo($indices_ticker, $contentType);
        return $response;
    }

    /**
     * Operation v2AggsTickerIndicesTickerPrevGetWithHttpInfo
     *
     * Previous Close
     *
     * @param  string $indices_ticker The ticker symbol of Index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerIndicesTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2AggsTickerIndicesTickerPrevGetWithHttpInfo($indices_ticker, string $contentType = self::contentTypes['v2AggsTickerIndicesTickerPrevGet'][0])
    {
        $request = $this->v2AggsTickerIndicesTickerPrevGetRequest($indices_ticker, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2AggsTickerIndicesTickerPrevGetAsync
     *
     * Previous Close
     *
     * @param  string $indices_ticker The ticker symbol of Index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerIndicesTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerIndicesTickerPrevGetAsync($indices_ticker, string $contentType = self::contentTypes['v2AggsTickerIndicesTickerPrevGet'][0])
    {
        return $this->v2AggsTickerIndicesTickerPrevGetAsyncWithHttpInfo($indices_ticker, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2AggsTickerIndicesTickerPrevGetAsyncWithHttpInfo
     *
     * Previous Close
     *
     * @param  string $indices_ticker The ticker symbol of Index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerIndicesTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerIndicesTickerPrevGetAsyncWithHttpInfo($indices_ticker, string $contentType = self::contentTypes['v2AggsTickerIndicesTickerPrevGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response';
        $request = $this->v2AggsTickerIndicesTickerPrevGetRequest($indices_ticker, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2AggsTickerIndicesTickerPrevGet'
     *
     * @param  string $indices_ticker The ticker symbol of Index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerIndicesTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2AggsTickerIndicesTickerPrevGetRequest($indices_ticker, string $contentType = self::contentTypes['v2AggsTickerIndicesTickerPrevGet'][0])
    {

        // verify the required parameter 'indices_ticker' is set
        if ($indices_ticker === null || (is_array($indices_ticker) && count($indices_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indices_ticker when calling v2AggsTickerIndicesTickerPrevGet'
            );
        }


        $resourcePath = '/v2/aggs/ticker/{indicesTicker}/prev';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($indices_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'indicesTicker' . '}',
                ObjectSerializer::toPathValue($indices_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet
     *
     * Aggregates (Bars)
     *
     * @param  string $indices_ticker The ticker symbol of Index. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response
     */
    public function v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet($indices_ticker, $multiplier, $timespan, $from, $to, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'][0])
    {
        list($response) = $this->v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetWithHttpInfo($indices_ticker, $multiplier, $timespan, $from, $to, $sort, $limit, $contentType);
        return $response;
    }

    /**
     * Operation v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetWithHttpInfo
     *
     * Aggregates (Bars)
     *
     * @param  string $indices_ticker The ticker symbol of Index. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetWithHttpInfo($indices_ticker, $multiplier, $timespan, $from, $to, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'][0])
    {
        $request = $this->v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetRequest($indices_ticker, $multiplier, $timespan, $from, $to, $sort, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetAsync
     *
     * Aggregates (Bars)
     *
     * @param  string $indices_ticker The ticker symbol of Index. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetAsync($indices_ticker, $multiplier, $timespan, $from, $to, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'][0])
    {
        return $this->v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetAsyncWithHttpInfo($indices_ticker, $multiplier, $timespan, $from, $to, $sort, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetAsyncWithHttpInfo
     *
     * Aggregates (Bars)
     *
     * @param  string $indices_ticker The ticker symbol of Index. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetAsyncWithHttpInfo($indices_ticker, $multiplier, $timespan, $from, $to, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V2AggsTickerIndicesTickerPrevGet200Response';
        $request = $this->v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetRequest($indices_ticker, $multiplier, $timespan, $from, $to, $sort, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'
     *
     * @param  string $indices_ticker The ticker symbol of Index. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetRequest($indices_ticker, $multiplier, $timespan, $from, $to, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'][0])
    {

        // verify the required parameter 'indices_ticker' is set
        if ($indices_ticker === null || (is_array($indices_ticker) && count($indices_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indices_ticker when calling v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'multiplier' is set
        if ($multiplier === null || (is_array($multiplier) && count($multiplier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $multiplier when calling v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'timespan' is set
        if ($timespan === null || (is_array($timespan) && count($timespan) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $timespan when calling v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet'
            );
        }




        $resourcePath = '/v2/aggs/ticker/{indicesTicker}/range/{multiplier}/{timespan}/{from}/{to}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($indices_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'indicesTicker' . '}',
                ObjectSerializer::toPathValue($indices_ticker),
                $resourcePath
            );
        }
        // path params
        if ($multiplier !== null) {
            $resourcePath = str_replace(
                '{' . 'multiplier' . '}',
                ObjectSerializer::toPathValue($multiplier),
                $resourcePath
            );
        }
        // path params
        if ($timespan !== null) {
            $resourcePath = str_replace(
                '{' . 'timespan' . '}',
                ObjectSerializer::toPathValue($timespan),
                $resourcePath
            );
        }
        // path params
        if ($from !== null) {
            $resourcePath = str_replace(
                '{' . 'from' . '}',
                ObjectSerializer::toPathValue($from),
                $resourcePath
            );
        }
        // path params
        if ($to !== null) {
            $resourcePath = str_replace(
                '{' . 'to' . '}',
                ObjectSerializer::toPathValue($to),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
