<?php
/**
 * FxaggregatesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Polygon API
 *
 * The future of fintech.
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.3.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * FxaggregatesApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class FxaggregatesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'forexEMA' => [
            'application/json',
        ],
        'forexMACD' => [
            'application/json',
        ],
        'forexRSI' => [
            'application/json',
        ],
        'forexSMA' => [
            'application/json',
        ],
        'v2AggsGroupedLocaleGlobalMarketFxDateGet' => [
            'application/json',
        ],
        'v2AggsTickerForexTickerPrevGet' => [
            'application/json',
        ],
        'v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation forexEMA
     *
     * Exponential Moving Average (EMA)
     *
     * @param  string $fx_ticker The ticker symbol for which to get exponential moving average (EMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexEMA'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CryptoEMA200Response
     */
    public function forexEMA($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexEMA'][0])
    {
        list($response) = $this->forexEMAWithHttpInfo($fx_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);
        return $response;
    }

    /**
     * Operation forexEMAWithHttpInfo
     *
     * Exponential Moving Average (EMA)
     *
     * @param  string $fx_ticker The ticker symbol for which to get exponential moving average (EMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexEMA'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CryptoEMA200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function forexEMAWithHttpInfo($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexEMA'][0])
    {
        $request = $this->forexEMARequest($fx_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CryptoEMA200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CryptoEMA200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CryptoEMA200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CryptoEMA200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CryptoEMA200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation forexEMAAsync
     *
     * Exponential Moving Average (EMA)
     *
     * @param  string $fx_ticker The ticker symbol for which to get exponential moving average (EMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexEMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexEMAAsync($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexEMA'][0])
    {
        return $this->forexEMAAsyncWithHttpInfo($fx_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation forexEMAAsyncWithHttpInfo
     *
     * Exponential Moving Average (EMA)
     *
     * @param  string $fx_ticker The ticker symbol for which to get exponential moving average (EMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexEMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexEMAAsyncWithHttpInfo($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexEMA'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CryptoEMA200Response';
        $request = $this->forexEMARequest($fx_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'forexEMA'
     *
     * @param  string $fx_ticker The ticker symbol for which to get exponential moving average (EMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexEMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function forexEMARequest($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexEMA'][0])
    {

        // verify the required parameter 'fx_ticker' is set
        if ($fx_ticker === null || (is_array($fx_ticker) && count($fx_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fx_ticker when calling forexEMA'
            );
        }








        if ($limit !== null && $limit > 5000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FxaggregatesApi.forexEMA, must be smaller than or equal to 5000.');
        }
        





        $resourcePath = '/v1/indicators/ema/{fxTicker}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $window,
            'window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_type,
            'series_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_underlying,
            'expand_underlying', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gte,
            'timestamp.gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gt,
            'timestamp.gt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lte,
            'timestamp.lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lt,
            'timestamp.lt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($fx_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'fxTicker' . '}',
                ObjectSerializer::toPathValue($fx_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation forexMACD
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $fx_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexMACD'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CryptoMACD200Response
     */
    public function forexMACD($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexMACD'][0])
    {
        list($response) = $this->forexMACDWithHttpInfo($fx_ticker, $timestamp, $timespan, $adjusted, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);
        return $response;
    }

    /**
     * Operation forexMACDWithHttpInfo
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $fx_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexMACD'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CryptoMACD200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function forexMACDWithHttpInfo($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexMACD'][0])
    {
        $request = $this->forexMACDRequest($fx_ticker, $timestamp, $timespan, $adjusted, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CryptoMACD200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CryptoMACD200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CryptoMACD200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CryptoMACD200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CryptoMACD200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation forexMACDAsync
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $fx_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexMACD'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexMACDAsync($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexMACD'][0])
    {
        return $this->forexMACDAsyncWithHttpInfo($fx_ticker, $timestamp, $timespan, $adjusted, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation forexMACDAsyncWithHttpInfo
     *
     * Moving Average Convergence/Divergence (MACD)
     *
     * @param  string $fx_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexMACD'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexMACDAsyncWithHttpInfo($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexMACD'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CryptoMACD200Response';
        $request = $this->forexMACDRequest($fx_ticker, $timestamp, $timespan, $adjusted, $short_window, $long_window, $signal_window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'forexMACD'
     *
     * @param  string $fx_ticker The ticker symbol for which to get MACD data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $short_window The short window size used to calculate MACD data. (optional, default to 12)
     * @param  int $long_window The long window size used to calculate MACD data. (optional, default to 26)
     * @param  int $signal_window The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param  string $series_type The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexMACD'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function forexMACDRequest($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $short_window = 12, $long_window = 26, $signal_window = 9, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexMACD'][0])
    {

        // verify the required parameter 'fx_ticker' is set
        if ($fx_ticker === null || (is_array($fx_ticker) && count($fx_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fx_ticker when calling forexMACD'
            );
        }










        if ($limit !== null && $limit > 5000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FxaggregatesApi.forexMACD, must be smaller than or equal to 5000.');
        }
        





        $resourcePath = '/v1/indicators/macd/{fxTicker}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short_window,
            'short_window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $long_window,
            'long_window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $signal_window,
            'signal_window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_type,
            'series_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_underlying,
            'expand_underlying', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gte,
            'timestamp.gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gt,
            'timestamp.gt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lte,
            'timestamp.lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lt,
            'timestamp.lt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($fx_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'fxTicker' . '}',
                ObjectSerializer::toPathValue($fx_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation forexRSI
     *
     * Relative Strength Index (RSI)
     *
     * @param  string $fx_ticker The ticker symbol for which to get relative strength index (RSI) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param  string $series_type The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexRSI'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CryptoRSI200Response
     */
    public function forexRSI($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 14, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexRSI'][0])
    {
        list($response) = $this->forexRSIWithHttpInfo($fx_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);
        return $response;
    }

    /**
     * Operation forexRSIWithHttpInfo
     *
     * Relative Strength Index (RSI)
     *
     * @param  string $fx_ticker The ticker symbol for which to get relative strength index (RSI) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param  string $series_type The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexRSI'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CryptoRSI200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function forexRSIWithHttpInfo($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 14, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexRSI'][0])
    {
        $request = $this->forexRSIRequest($fx_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CryptoRSI200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CryptoRSI200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CryptoRSI200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CryptoRSI200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CryptoRSI200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation forexRSIAsync
     *
     * Relative Strength Index (RSI)
     *
     * @param  string $fx_ticker The ticker symbol for which to get relative strength index (RSI) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param  string $series_type The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexRSI'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexRSIAsync($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 14, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexRSI'][0])
    {
        return $this->forexRSIAsyncWithHttpInfo($fx_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation forexRSIAsyncWithHttpInfo
     *
     * Relative Strength Index (RSI)
     *
     * @param  string $fx_ticker The ticker symbol for which to get relative strength index (RSI) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param  string $series_type The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexRSI'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexRSIAsyncWithHttpInfo($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 14, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexRSI'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CryptoRSI200Response';
        $request = $this->forexRSIRequest($fx_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'forexRSI'
     *
     * @param  string $fx_ticker The ticker symbol for which to get relative strength index (RSI) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param  string $series_type The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexRSI'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function forexRSIRequest($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 14, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexRSI'][0])
    {

        // verify the required parameter 'fx_ticker' is set
        if ($fx_ticker === null || (is_array($fx_ticker) && count($fx_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fx_ticker when calling forexRSI'
            );
        }








        if ($limit !== null && $limit > 5000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FxaggregatesApi.forexRSI, must be smaller than or equal to 5000.');
        }
        





        $resourcePath = '/v1/indicators/rsi/{fxTicker}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $window,
            'window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_type,
            'series_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_underlying,
            'expand_underlying', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gte,
            'timestamp.gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gt,
            'timestamp.gt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lte,
            'timestamp.lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lt,
            'timestamp.lt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($fx_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'fxTicker' . '}',
                ObjectSerializer::toPathValue($fx_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation forexSMA
     *
     * Simple Moving Average (SMA)
     *
     * @param  string $fx_ticker The ticker symbol for which to get simple moving average (SMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexSMA'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CryptoSMA200Response
     */
    public function forexSMA($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexSMA'][0])
    {
        list($response) = $this->forexSMAWithHttpInfo($fx_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);
        return $response;
    }

    /**
     * Operation forexSMAWithHttpInfo
     *
     * Simple Moving Average (SMA)
     *
     * @param  string $fx_ticker The ticker symbol for which to get simple moving average (SMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexSMA'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CryptoSMA200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function forexSMAWithHttpInfo($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexSMA'][0])
    {
        $request = $this->forexSMARequest($fx_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CryptoSMA200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CryptoSMA200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CryptoSMA200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CryptoSMA200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CryptoSMA200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation forexSMAAsync
     *
     * Simple Moving Average (SMA)
     *
     * @param  string $fx_ticker The ticker symbol for which to get simple moving average (SMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexSMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexSMAAsync($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexSMA'][0])
    {
        return $this->forexSMAAsyncWithHttpInfo($fx_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation forexSMAAsyncWithHttpInfo
     *
     * Simple Moving Average (SMA)
     *
     * @param  string $fx_ticker The ticker symbol for which to get simple moving average (SMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexSMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexSMAAsyncWithHttpInfo($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexSMA'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CryptoSMA200Response';
        $request = $this->forexSMARequest($fx_ticker, $timestamp, $timespan, $adjusted, $window, $series_type, $expand_underlying, $order, $limit, $timestamp_gte, $timestamp_gt, $timestamp_lte, $timestamp_lt, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'forexSMA'
     *
     * @param  string $fx_ticker The ticker symbol for which to get simple moving average (SMA) data. (required)
     * @param  string $timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param  string $timespan The size of the aggregate time window. (optional, default to 'day')
     * @param  bool $adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param  int $window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param  string $series_type The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to 'close')
     * @param  bool $expand_underlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param  string $order The order in which to return the results, ordered by timestamp. (optional, default to 'desc')
     * @param  int $limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param  string $timestamp_gte Range by timestamp. (optional)
     * @param  string $timestamp_gt Range by timestamp. (optional)
     * @param  string $timestamp_lte Range by timestamp. (optional)
     * @param  string $timestamp_lt Range by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forexSMA'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function forexSMARequest($fx_ticker, $timestamp = null, $timespan = 'day', $adjusted = true, $window = 50, $series_type = 'close', $expand_underlying = false, $order = 'desc', $limit = 10, $timestamp_gte = null, $timestamp_gt = null, $timestamp_lte = null, $timestamp_lt = null, string $contentType = self::contentTypes['forexSMA'][0])
    {

        // verify the required parameter 'fx_ticker' is set
        if ($fx_ticker === null || (is_array($fx_ticker) && count($fx_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fx_ticker when calling forexSMA'
            );
        }








        if ($limit !== null && $limit > 5000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FxaggregatesApi.forexSMA, must be smaller than or equal to 5000.');
        }
        





        $resourcePath = '/v1/indicators/sma/{fxTicker}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $window,
            'window', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_type,
            'series_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_underlying,
            'expand_underlying', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gte,
            'timestamp.gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_gt,
            'timestamp.gt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lte,
            'timestamp.lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp_lt,
            'timestamp.lt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($fx_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'fxTicker' . '}',
                ObjectSerializer::toPathValue($fx_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v2AggsGroupedLocaleGlobalMarketFxDateGet
     *
     * Grouped Daily (Bars)
     *
     * @param  string $date The beginning date for the aggregate window. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsGroupedLocaleGlobalMarketFxDateGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response
     */
    public function v2AggsGroupedLocaleGlobalMarketFxDateGet($date, $adjusted = null, string $contentType = self::contentTypes['v2AggsGroupedLocaleGlobalMarketFxDateGet'][0])
    {
        list($response) = $this->v2AggsGroupedLocaleGlobalMarketFxDateGetWithHttpInfo($date, $adjusted, $contentType);
        return $response;
    }

    /**
     * Operation v2AggsGroupedLocaleGlobalMarketFxDateGetWithHttpInfo
     *
     * Grouped Daily (Bars)
     *
     * @param  string $date The beginning date for the aggregate window. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsGroupedLocaleGlobalMarketFxDateGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2AggsGroupedLocaleGlobalMarketFxDateGetWithHttpInfo($date, $adjusted = null, string $contentType = self::contentTypes['v2AggsGroupedLocaleGlobalMarketFxDateGet'][0])
    {
        $request = $this->v2AggsGroupedLocaleGlobalMarketFxDateGetRequest($date, $adjusted, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2AggsGroupedLocaleGlobalMarketFxDateGetAsync
     *
     * Grouped Daily (Bars)
     *
     * @param  string $date The beginning date for the aggregate window. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsGroupedLocaleGlobalMarketFxDateGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsGroupedLocaleGlobalMarketFxDateGetAsync($date, $adjusted = null, string $contentType = self::contentTypes['v2AggsGroupedLocaleGlobalMarketFxDateGet'][0])
    {
        return $this->v2AggsGroupedLocaleGlobalMarketFxDateGetAsyncWithHttpInfo($date, $adjusted, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2AggsGroupedLocaleGlobalMarketFxDateGetAsyncWithHttpInfo
     *
     * Grouped Daily (Bars)
     *
     * @param  string $date The beginning date for the aggregate window. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsGroupedLocaleGlobalMarketFxDateGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsGroupedLocaleGlobalMarketFxDateGetAsyncWithHttpInfo($date, $adjusted = null, string $contentType = self::contentTypes['v2AggsGroupedLocaleGlobalMarketFxDateGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response';
        $request = $this->v2AggsGroupedLocaleGlobalMarketFxDateGetRequest($date, $adjusted, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2AggsGroupedLocaleGlobalMarketFxDateGet'
     *
     * @param  string $date The beginning date for the aggregate window. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsGroupedLocaleGlobalMarketFxDateGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2AggsGroupedLocaleGlobalMarketFxDateGetRequest($date, $adjusted = null, string $contentType = self::contentTypes['v2AggsGroupedLocaleGlobalMarketFxDateGet'][0])
    {

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling v2AggsGroupedLocaleGlobalMarketFxDateGet'
            );
        }



        $resourcePath = '/v2/aggs/grouped/locale/global/market/fx/{date}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($date !== null) {
            $resourcePath = str_replace(
                '{' . 'date' . '}',
                ObjectSerializer::toPathValue($date),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v2AggsTickerForexTickerPrevGet
     *
     * Previous Close
     *
     * @param  string $forex_ticker The ticker symbol of the currency pair. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerForexTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response
     */
    public function v2AggsTickerForexTickerPrevGet($forex_ticker, $adjusted = null, string $contentType = self::contentTypes['v2AggsTickerForexTickerPrevGet'][0])
    {
        list($response) = $this->v2AggsTickerForexTickerPrevGetWithHttpInfo($forex_ticker, $adjusted, $contentType);
        return $response;
    }

    /**
     * Operation v2AggsTickerForexTickerPrevGetWithHttpInfo
     *
     * Previous Close
     *
     * @param  string $forex_ticker The ticker symbol of the currency pair. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerForexTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2AggsTickerForexTickerPrevGetWithHttpInfo($forex_ticker, $adjusted = null, string $contentType = self::contentTypes['v2AggsTickerForexTickerPrevGet'][0])
    {
        $request = $this->v2AggsTickerForexTickerPrevGetRequest($forex_ticker, $adjusted, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2AggsTickerForexTickerPrevGetAsync
     *
     * Previous Close
     *
     * @param  string $forex_ticker The ticker symbol of the currency pair. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerForexTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerForexTickerPrevGetAsync($forex_ticker, $adjusted = null, string $contentType = self::contentTypes['v2AggsTickerForexTickerPrevGet'][0])
    {
        return $this->v2AggsTickerForexTickerPrevGetAsyncWithHttpInfo($forex_ticker, $adjusted, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2AggsTickerForexTickerPrevGetAsyncWithHttpInfo
     *
     * Previous Close
     *
     * @param  string $forex_ticker The ticker symbol of the currency pair. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerForexTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerForexTickerPrevGetAsyncWithHttpInfo($forex_ticker, $adjusted = null, string $contentType = self::contentTypes['v2AggsTickerForexTickerPrevGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerPrevGet200Response';
        $request = $this->v2AggsTickerForexTickerPrevGetRequest($forex_ticker, $adjusted, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2AggsTickerForexTickerPrevGet'
     *
     * @param  string $forex_ticker The ticker symbol of the currency pair. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerForexTickerPrevGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2AggsTickerForexTickerPrevGetRequest($forex_ticker, $adjusted = null, string $contentType = self::contentTypes['v2AggsTickerForexTickerPrevGet'][0])
    {

        // verify the required parameter 'forex_ticker' is set
        if ($forex_ticker === null || (is_array($forex_ticker) && count($forex_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $forex_ticker when calling v2AggsTickerForexTickerPrevGet'
            );
        }



        $resourcePath = '/v2/aggs/ticker/{forexTicker}/prev';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($forex_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'forexTicker' . '}',
                ObjectSerializer::toPathValue($forex_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet
     *
     * Aggregates (Bars)
     *
     * @param  string $forex_ticker The ticker symbol of the currency pair. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response
     */
    public function v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet($forex_ticker, $multiplier, $timespan, $from, $to, $adjusted = null, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'][0])
    {
        list($response) = $this->v2AggsTickerForexTickerRangeMultiplierTimespanFromToGetWithHttpInfo($forex_ticker, $multiplier, $timespan, $from, $to, $adjusted, $sort, $limit, $contentType);
        return $response;
    }

    /**
     * Operation v2AggsTickerForexTickerRangeMultiplierTimespanFromToGetWithHttpInfo
     *
     * Aggregates (Bars)
     *
     * @param  string $forex_ticker The ticker symbol of the currency pair. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2AggsTickerForexTickerRangeMultiplierTimespanFromToGetWithHttpInfo($forex_ticker, $multiplier, $timespan, $from, $to, $adjusted = null, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'][0])
    {
        $request = $this->v2AggsTickerForexTickerRangeMultiplierTimespanFromToGetRequest($forex_ticker, $multiplier, $timespan, $from, $to, $adjusted, $sort, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2AggsTickerForexTickerRangeMultiplierTimespanFromToGetAsync
     *
     * Aggregates (Bars)
     *
     * @param  string $forex_ticker The ticker symbol of the currency pair. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerForexTickerRangeMultiplierTimespanFromToGetAsync($forex_ticker, $multiplier, $timespan, $from, $to, $adjusted = null, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'][0])
    {
        return $this->v2AggsTickerForexTickerRangeMultiplierTimespanFromToGetAsyncWithHttpInfo($forex_ticker, $multiplier, $timespan, $from, $to, $adjusted, $sort, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2AggsTickerForexTickerRangeMultiplierTimespanFromToGetAsyncWithHttpInfo
     *
     * Aggregates (Bars)
     *
     * @param  string $forex_ticker The ticker symbol of the currency pair. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2AggsTickerForexTickerRangeMultiplierTimespanFromToGetAsyncWithHttpInfo($forex_ticker, $multiplier, $timespan, $from, $to, $adjusted = null, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response';
        $request = $this->v2AggsTickerForexTickerRangeMultiplierTimespanFromToGetRequest($forex_ticker, $multiplier, $timespan, $from, $to, $adjusted, $sort, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'
     *
     * @param  string $forex_ticker The ticker symbol of the currency pair. (required)
     * @param  int $multiplier The size of the timespan multiplier. (required)
     * @param  string $timespan The size of the time window. (required)
     * @param  string $from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  string $to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (required)
     * @param  bool $adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional)
     * @param  string $sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). (optional)
     * @param  int $limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2AggsTickerForexTickerRangeMultiplierTimespanFromToGetRequest($forex_ticker, $multiplier, $timespan, $from, $to, $adjusted = null, $sort = null, $limit = null, string $contentType = self::contentTypes['v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'][0])
    {

        // verify the required parameter 'forex_ticker' is set
        if ($forex_ticker === null || (is_array($forex_ticker) && count($forex_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $forex_ticker when calling v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'multiplier' is set
        if ($multiplier === null || (is_array($multiplier) && count($multiplier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $multiplier when calling v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'timespan' is set
        if ($timespan === null || (is_array($timespan) && count($timespan) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $timespan when calling v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'
            );
        }

        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet'
            );
        }





        $resourcePath = '/v2/aggs/ticker/{forexTicker}/range/{multiplier}/{timespan}/{from}/{to}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adjusted,
            'adjusted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($forex_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'forexTicker' . '}',
                ObjectSerializer::toPathValue($forex_ticker),
                $resourcePath
            );
        }
        // path params
        if ($multiplier !== null) {
            $resourcePath = str_replace(
                '{' . 'multiplier' . '}',
                ObjectSerializer::toPathValue($multiplier),
                $resourcePath
            );
        }
        // path params
        if ($timespan !== null) {
            $resourcePath = str_replace(
                '{' . 'timespan' . '}',
                ObjectSerializer::toPathValue($timespan),
                $resourcePath
            );
        }
        // path params
        if ($from !== null) {
            $resourcePath = str_replace(
                '{' . 'from' . '}',
                ObjectSerializer::toPathValue($from),
                $resourcePath
            );
        }
        // path params
        if ($to !== null) {
            $resourcePath = str_replace(
                '{' . 'to' . '}',
                ObjectSerializer::toPathValue($to),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
